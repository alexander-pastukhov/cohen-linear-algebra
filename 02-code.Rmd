# Code

## Chapter 2

### Code block 2.1/2.2 {-}
```{r}
aScalar <- 4
```

### Code block 2.3/2.4 {-}
This is, admittedly, a "fancy" [ggplot2](https://ggplot2.tidyverse.org/) rather than base R version. But _ggplot2_ figures do look so much better.
```{r}
library(ggplot2)

v <- c(2, -1)
ggplot(data=NULL, aes(x = c(0, v[1]), y=c(0, v[2])))  + 
  geom_line() + 
  geom_point(aes(x=v[1], y=v[2])) + 
  scale_x_continuous(name=expression(paste(X[1], " dim.")), limits = c(-3, 3)) + 
  scale_y_continuous(name=expression(paste(X[2], " dim.")), limits = c(-3, 3)) + 
  coord_equal()
```

### Code block 2.5/2.6 {-}
In R _atomic_ vectors are created via `c()` function but, technically, they are neither column, nor row vectors. [Matrix multiplication manual](https://stat.ethz.ch/R-manual/R-devel/library/base/html/matmult.html) states that it: "_Multiplies two matrices, if they are conformable. If one argument is a vector, it will be promoted to either a row or column matrix to make the two arguments conformable. If both are vectors of the same length, it will return the inner product (as a matrix)._" At the same time, _transposing_ an atomic vector `t(c(...))` transforms it into a single row matrix, thus a row vector, hinting, that deep down an outcome of `c()` is a column vector.

To avoid ambiguity, I will use single row and single column matrices for, respectively, row and column vectors.

```{r}
v1 <- matrix(c(2, 5, 5, 7), nrow = 1) # row vector
v2 <- matrix(c(2, 5, 5, 7), ncol = 1) # column vector
```

### Code block 2.7/2.8 {-}
```{r}
v1 <- matrix(c(2, 5, 5, 7), nrow = 1) # row vector
v2 <- t(v1)                           # column vector
```
 

### Code block 2.9/2.10 {-}
For this example, you can use atomic vectors directly, of course, without turning them into a single column matrix.
```{r}
v1 <- matrix(c(2, 5, 4, 7), ncol=1)
v2 <- matrix(c(4, 1, 0, 2), ncol=1)
v3 <- 4 * v1  - 2 * v2
```

## Chapter 3

### Code block 3.1/3.2 {-}
Oddly enough, there is no _explicit_ dot product function in base R but there are multiple implementations in various libraries such as [pracma](https://github.com/cran/pracma).
```{r}
library(pracma)

v1 <- matrix(c(2, 5, 4, 7), ncol=1)
v2 <- matrix(c(4, 1, 0, 2), ncol=1)
dp <- dot(v1, v2)
```

However, a matrix multiplication of _atomic_ vectors (we can convert a matrix back to an atomic vector via `c()` or `as.vector()`) gives us the dot product (well, the _inner_ product, which is why the results is 1-by-1 matrix).
```{r}
dp <- c(v1) %*% as.vector(v2)
```

One can, of course, implement it by hand (`*` here is elementwise multiplication, a.k.a. Hadamard product).
```{r}
dp <- sum(v1 * v2)
```

Or use matrix multiplication with a transpose of the first vector (`%*%` is matrix multiplication).
```{r}
dp <- t(v1) %*% v2
```

### Code block 3.3/3.4 {-}
```{r}
l1 <- 1
l2 <- 2
l3 <- -3
v1 <- matrix(c(4, 5, 1))
v2 <- matrix(c(-4, 0, -4))
v3 <- matrix(c(1, 3, 2))
l1 * v1 + l2 * v2 + l3 * v3
```

### Code block 3.5/3.6 {-}
To compute the outer product, we must use atomic vectors, thus I've skipped the whole creating-column-vector-as-a-matrix thing.
```{r}
v1 <- c(2, 5, 4, 7)
v2 <- c(4, 1, 0, 2)
op <- outer(v1, v2)
op <- v1 %o% v2 # alternative call as operation
```

Alternatively, if we do start with vectors as single column matrices...
```{r}
v1 <- matrix(c(2, 5, 4, 7))
v2 <- matrix(c(4, 1, 0, 2))
op <- outer(c(v1), c(v2))
op <- c(v1) %o% c(v2) # alternative call as operation
```

### Code block 3.7/3.8 {-}
```{r}
v1 <- matrix(c(2, 5, 4, 7))
v2 <- matrix(c(4, 1, 0, 2))
v3 <- v1 * v2
```

### Code block 3.9/3.10 {-}
Please note that you need to explicitly specify the 2-norm via `type="2"`, as the _one norm_ is used by default.
```{r}
v <- matrix(c(2, 5, 4, 7))
vMag <- norm(v, type="2")
v_unit <- v / vMag
```

## Chapter 5

### Code block 5.1/5.2 {-}
There is only one way to transpose a matrix in R: via function [t()](https://stat.ethz.ch/R-manual/R-devel/library/base/html/t.html).

```{r}
A <- matrix(runif(n=2*5), nrow=2)
At1 <- t(A)
```

### Code block 5.3/5.4 {-}
```{r}
I <- diag(4)
O <- rep(1, times=4)
Z <- matrix(rep(0, 4 * 4), nrow = 4)
```

### Code block 5.5/5.6 {-}
```{r}
D <- diag(c(1, 2, 3, 5))  # diagonal matrix
R <- matrix(runif(n = 3 * 4), nrow=3)
d <- diag(R) # diagonal elements
```

### Code block 5.7/5.8 {-}
In r [cbind()](https://stat.ethz.ch/R-manual/R-devel/library/base/html/cbind.html) and [rbind()](https://stat.ethz.ch/R-manual/R-devel/library/base/html/cbind.html) concatenate, respectively, by column and row.
```{r}
A <- matrix(runif(n = 3 * 5), nrow=3)
B <- matrix(runif(n = 3 * 4), nrow=3)
AB <- cbind(A, B)
```

### Code block 5.9/5.10 {-}
There are two ways to compute lower and upper triangular parts of a matrix. First, to use `tril()` and `triu()` function from _pracma_ library.
```{r}
A <- matrix(runif(n = 5 * 5), nrow=5)
L <- tril(A)
U <- triu(A)
```

Alternatively, you can use base R functions [lower.tri()](https://stat.ethz.ch/R-manual/R-devel/library/base/html/lower.tri.html) and `upper.tri()` that give you a matrix of the same size with _logical_ values indicating whether an element belongs to, respectively, lower or upper triangle. Note that by default, the diagonal _is not_ included!
```{r}
A <- matrix(runif(n = 5 * 5), nrow=5)

L <- A
# by setting the UPPER triangular part to 0, we get the LOWER triangular part and the diagonal
L[upper.tri(L)] <- 0

U <- A
# by setting the LOWER triangular part to 0, we get the UPPER triangular part and the diagonal
U[lower.tri(U)] <- 0
```

### Code block 5.11/5.12 {-}
Note that there is a `toeplitz()` function in _stats_ (base R) and `Topelitz()` (note the first capital letter) in _pracma_ library. Here, I use base R version.
```{r}
t <- c(1, 2, 3, 4)
T <- stats::toeplitz(t)
H <- pracma::hankel(t, b= c(t[-1], t[1]))
```
### Code block 5.13/5.14 {-}
```{r}
l <- 0.01
I <- diag(4)
A <- matrix(runif(4 * 4), nrow=4)
As <- A + l * I
```

### Code block 5.15/5.16 {-}
There is no trace function in R as you can easily implement it as a sum of diagonal elements:
```{r}
A <- matrix(runif(4 * 4), nrow=4)
tr <- sum(diag(A))
```

However, if you absolutely insist on having it as a function, use `tr()` from _psych_ library:
```{r}
A <- matrix(runif(4 * 4), nrow=4)
tr <- psych::tr(A)
```


## Chapter 6
### Code block 6.1/6.2 {-}
```{r}
M1 <- matrix(runif(n=4*3), nrow=4, ncol=3)
M2 <- matrix(runif(n=3*5), nrow=3, ncol=5)
C <- M1 %*% M2
```

### Code block 6.3/6.4 {-}
```{r}
A <- matrix(runif(n=2*2), nrow=2, ncol=2)
B <- matrix(runif(n=2*2), nrow=2, ncol=2)
C1 <- A %*% B
C2 <- B %*% A
```

### Code block 6.5/6.6 {-}
```{r}
M1 <- matrix(runif(n=4*3), nrow=4, ncol=3)
M2 <- matrix(runif(n=4*3), nrow=4, ncol=3)
C <- M1 * M2
```


### Code block 6.7/6.8 {-}
Note that by default, matrix is constructed by column. To match the code, we need to use `byrow=TRUE` option.
```{r}
A <- matrix(c(1, 2, 3, 4, 5, 6), nrow=2, byrow = TRUE)
c(A)
```

### Code block 6.9/6.10 {-}
Here, I use `sum(diag())` instead of the dedicated `psych::tr()`.
```{r}
A <- matrix(runif(n=4*3), nrow=4, ncol=3)
B <- matrix(runif(n=4*3), nrow=4, ncol=3)
f <- sum(diag(t(A) %*% B))
```

### Code block 6.11/6.12 {-}
```{r}
A <- matrix(runif(n=4*3), nrow=4, ncol=3)
norm(A, type="F")
```


